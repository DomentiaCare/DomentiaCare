// data/model/RecordViewModel.kt
package com.example.domentiacare.data.model

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.example.domentiacare.data.local.RecordStorage
import com.example.domentiacare.data.local.SimpleLocalStorage
import com.example.domentiacare.data.local.SimpleSchedule
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.io.File

class RecordViewModel(application: Application) : AndroidViewModel(application) {

    private val recordStorage = RecordStorage(application)
    private val simpleLocalStorage = SimpleLocalStorage(application)

    private val _records = MutableStateFlow<List<Record>>(emptyList())
    val records: StateFlow<List<Record>> = _records

    private val _isProcessing = MutableStateFlow(false)
    val isProcessing: StateFlow<Boolean> = _isProcessing

    init {
        loadAllData()
    }

    // Î™®Îì† Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    fun loadAllData() {
        viewModelScope.launch {
            Log.d("RecordViewModel", "=== Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë ===")
            val records = recordStorage.getAllRecords()
            _records.value = records
            Log.d("RecordViewModel", "‚úÖ Record Ï¥ù ${records.size}Í∞ú Î°úÎìú ÏôÑÎ£å")

            records.forEach { record ->
                Log.d("RecordViewModel", "üìã Record: ${record.name}")
                Log.d("RecordViewModel", "  - ID: ${record.localId}")
                Log.d("RecordViewModel", "  - Transcript ÏÉÅÌÉú: ${record.transcriptStatus}")
                Log.d("RecordViewModel", "  - Analysis ÏÉÅÌÉú: ${record.analysisStatus}")
                Log.d("RecordViewModel", "  - Parse ÏÉÅÌÉú: ${record.parseStatus}")
                Log.d("RecordViewModel", "  - Ï∂îÏ∂úÎêú ÏùºÏ†ï Í∞úÏàò: ${record.extractedSchedules?.size ?: 0}")

                record.extractedSchedules?.forEachIndexed { index, schedule ->
                    Log.d("RecordViewModel", "    üìÖ ÏùºÏ†ï ${index + 1}: ${schedule.title}")
                    Log.d("RecordViewModel", "      - ÏãúÏûë: ${schedule.startDate}")
                    Log.d("RecordViewModel", "      - ÏÑ§Î™Ö: ${schedule.description}")
                }
            }
            Log.d("RecordViewModel", "=== Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å ===")
        }
    }

    // ÌÜµÌôî ÎÖπÏùå ÌååÏùºÎì§ÏùÑ Ïä§Ï∫îÌïòÏó¨ ÏÉàÎ°úÏö¥ Record ÏÉùÏÑ±
    fun scanAndImportRecordings(userId: Long) {
        viewModelScope.launch {
            Log.d("RecordViewModel", "=== ÎÖπÏùå ÌååÏùº Ïä§Ï∫î ÏãúÏûë ===")
            Log.d("RecordViewModel", "ÏÇ¨Ïö©Ïûê ID: $userId")

            val dir = File("/sdcard/Recordings/Call/")
            Log.d("RecordViewModel", "Ïä§Ï∫î Í≤ΩÎ°ú: ${dir.absolutePath}")

            if (dir.exists() && dir.isDirectory) {
                Log.d("RecordViewModel", "‚úÖ ÎîîÎ†âÌÜ†Î¶¨ Ï°¥Ïû¨ ÌôïÏù∏")

                val audioFiles = dir.listFiles { file ->
                    file.isFile && (file.extension.equals("m4a", true) ||
                            file.extension.equals("wav", true) ||
                            file.extension.equals("mp3", true))
                }?.map { file ->
                    RecordingFile(
                        name = file.name,
                        path = file.absolutePath,
                        lastModified = file.lastModified(),
                        size = file.length()
                    )
                } ?: emptyList()

                Log.d("RecordViewModel", "üìÅ Î∞úÍ≤¨Îêú Ïò§ÎîîÏò§ ÌååÏùº: ${audioFiles.size}Í∞ú")
                audioFiles.forEach { file ->
                    Log.d("RecordViewModel", "  - ${file.name} (${file.size} bytes)")
                }

                // Í∏∞Ï°¥ RecordÎì§Í≥º ÎπÑÍµêÌïòÏó¨ ÏÉàÎ°úÏö¥ ÌååÏùºÎßå Ï∂îÍ∞Ä
                val existingRecords = recordStorage.getAllRecords()
                val existingPaths = existingRecords.map { it.path }.toSet()
                Log.d("RecordViewModel", "üìã Í∏∞Ï°¥ Record: ${existingRecords.size}Í∞ú")

                val newRecordings = audioFiles.filter { it.path !in existingPaths }
                Log.d("RecordViewModel", "üÜï ÏÉàÎ°úÏö¥ ÌååÏùº: ${newRecordings.size}Í∞ú")

                newRecordings.forEach { recording ->
                    Log.d("RecordViewModel", "üì• ÏÉà Record ÏÉùÏÑ±: ${recording.name}")
                    val record = recording.toRecord(userId)
                    val result = recordStorage.saveRecord(record)
                    if (result.isSuccess) {
                        Log.d("RecordViewModel", "‚úÖ Record Ï†ÄÏû• ÏÑ±Í≥µ: ${record.localId}")
                    } else {
                        Log.e("RecordViewModel", "‚ùå Record Ï†ÄÏû• Ïã§Ìå®: ${result.exceptionOrNull()?.message}")
                    }
                }

                loadAllData()
            } else {
                Log.w("RecordViewModel", "‚ö†Ô∏è ÎîîÎ†âÌÜ†Î¶¨Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå: ${dir.absolutePath}")
            }
            Log.d("RecordViewModel", "=== ÎÖπÏùå ÌååÏùº Ïä§Ï∫î ÏôÑÎ£å ===")
        }
    }

    // Whisper Ï≤òÎ¶¨ ÏãúÏûë
    fun startWhisperProcessing(recordId: String) {
        viewModelScope.launch {
            recordStorage.updateProcessStatus(
                recordId,
                transcriptStatus = ProcessStatus.PROCESSING
            )
            processWithWhisper(recordId)
            loadAllData()
        }
    }

    // Llama Î∂ÑÏÑù ÏãúÏûë
    fun startLlamaAnalysis(recordId: String) {
        viewModelScope.launch {
            recordStorage.updateProcessStatus(
                recordId,
                analysisStatus = ProcessStatus.PROCESSING
            )
            processWithLlama(recordId)
            loadAllData()
        }
    }

    // ÏùºÏ†ï ÌååÏã± ÏãúÏûë
    fun startScheduleParsing(recordId: String) {
        viewModelScope.launch {
            recordStorage.updateProcessStatus(
                recordId,
                parseStatus = ProcessStatus.PROCESSING
            )
            parseScheduleFromResult(recordId)
            loadAllData()
        }
    }

    // Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìñâ (Whisper -> Llama -> Parse)
    fun processFullPipeline(recordId: String) {
        viewModelScope.launch {
            Log.d("RecordViewModel", "=== Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏãúÏûë ===")
            Log.d("RecordViewModel", "Ï≤òÎ¶¨Ìï† Record ID: $recordId")

            _isProcessing.value = true

            try {
                // 1. Whisper Ï≤òÎ¶¨
                Log.d("RecordViewModel", "üéôÔ∏è 1Îã®Í≥Ñ: Whisper Ï≤òÎ¶¨ ÏãúÏûë")
                recordStorage.updateProcessStatus(recordId, transcriptStatus = ProcessStatus.PROCESSING)
                processWithWhisper(recordId)
                Log.d("RecordViewModel", "‚úÖ 1Îã®Í≥Ñ: Whisper Ï≤òÎ¶¨ ÏôÑÎ£å")

                // 2. Llama Î∂ÑÏÑù
                Log.d("RecordViewModel", "üß† 2Îã®Í≥Ñ: Llama Î∂ÑÏÑù ÏãúÏûë")
                recordStorage.updateProcessStatus(recordId, analysisStatus = ProcessStatus.PROCESSING)
                processWithLlama(recordId)
                Log.d("RecordViewModel", "‚úÖ 2Îã®Í≥Ñ: Llama Î∂ÑÏÑù ÏôÑÎ£å")

                // 3. ÏùºÏ†ï ÌååÏã±
                Log.d("RecordViewModel", "üìÖ 3Îã®Í≥Ñ: ÏùºÏ†ï ÌååÏã± ÏãúÏûë")
                recordStorage.updateProcessStatus(recordId, parseStatus = ProcessStatus.PROCESSING)
                parseScheduleFromResult(recordId)
                Log.d("RecordViewModel", "‚úÖ 3Îã®Í≥Ñ: ÏùºÏ†ï ÌååÏã± ÏôÑÎ£å")

                // ÏµúÏ¢Ö Í≤∞Í≥º ÌôïÏù∏
                val finalRecord = recordStorage.getRecordById(recordId)
                Log.d("RecordViewModel", "üéâ Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÑ±Í≥µ!")
                Log.d("RecordViewModel", "  - ÏµúÏ¢Ö ÏÉÅÌÉú: T:${finalRecord?.transcriptStatus}, A:${finalRecord?.analysisStatus}, P:${finalRecord?.parseStatus}")
                Log.d("RecordViewModel", "  - Ï∂îÏ∂úÎêú ÏùºÏ†ï Ïàò: ${finalRecord?.extractedSchedules?.size ?: 0}")

            } catch (e: Exception) {
                Log.e("RecordViewModel", "‚ùå ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìñâ Ï§ë Ïò§Î•ò: ${e.message}", e)
                // ÏóêÎü¨ Ï≤òÎ¶¨
                recordStorage.updateProcessStatus(
                    recordId,
                    transcriptStatus = ProcessStatus.FAILED,
                    analysisStatus = ProcessStatus.FAILED,
                    parseStatus = ProcessStatus.FAILED
                )
            } finally {
                _isProcessing.value = false
                loadAllData()
                Log.d("RecordViewModel", "=== Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ Ï¢ÖÎ£å ===")
            }
        }
    }

    // Ïã§Ï†ú Whisper Ï≤òÎ¶¨ (Íµ¨ÌòÑ ÌïÑÏöî)
    private suspend fun processWithWhisper(recordId: String) {
        Log.d("RecordViewModel", "üéôÔ∏è Whisper Ï≤òÎ¶¨ ÏãúÏûë: $recordId")
        val record = recordStorage.getRecordById(recordId) ?: run {
            Log.e("RecordViewModel", "‚ùå RecordÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: $recordId")
            return
        }

        Log.d("RecordViewModel", "üìÅ Ï≤òÎ¶¨Ìï† ÌååÏùº: ${record.path}")
        Log.d("RecordViewModel", "üìè ÌååÏùº ÌÅ¨Í∏∞: ${record.size} bytes")

        try {
            // TODO: Ïã§Ï†ú Whisper Ïò®-ÎîîÎ∞îÏù¥Ïä§ Ï≤òÎ¶¨ Î°úÏßÅ
            val transcript = "Ïù¥Í≤ÉÏùÄ WhisperÎ°ú Î≥ÄÌôòÎêú ÌÖçÏä§Ìä∏ÏûÖÎãàÎã§. Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ${record.path} ÌååÏùºÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§. ÎÇ¥Ïùº Ïò§ÌõÑ 2ÏãúÏóê Î≥ëÏõêÏóê Í∞ÄÏïº Ìï¥Ïöî. Ï†ïÍ∏∞ Í≤ÄÏßÑ Î∞õÏúºÎü¨ Í∞ëÎãàÎã§."

            Log.d("RecordViewModel", "üìù Whisper Î≥ÄÌôò Í≤∞Í≥º:")
            Log.d("RecordViewModel", "  Í∏∏Ïù¥: ${transcript.length}Ïûê")
            Log.d("RecordViewModel", "  ÎÇ¥Ïö©: ${transcript.take(100)}${if (transcript.length > 100) "..." else ""}")

            recordStorage.updateTranscript(recordId, transcript, ProcessStatus.COMPLETED)
            Log.d("RecordViewModel", "‚úÖ Whisper Ï≤òÎ¶¨ ÏôÑÎ£å Î∞è Ï†ÄÏû• ÏÑ±Í≥µ")

        } catch (e: Exception) {
            Log.e("RecordViewModel", "‚ùå Whisper Ï≤òÎ¶¨ Ïã§Ìå®: ${e.message}", e)
            recordStorage.updateProcessStatus(recordId, transcriptStatus = ProcessStatus.FAILED)
        }
    }

    // Ïã§Ï†ú Llama Ï≤òÎ¶¨ (Íµ¨ÌòÑ ÌïÑÏöî)
    private suspend fun processWithLlama(recordId: String) {
        Log.d("RecordViewModel", "üß† Llama Î∂ÑÏÑù ÏãúÏûë: $recordId")
        val record = recordStorage.getRecordById(recordId) ?: run {
            Log.e("RecordViewModel", "‚ùå RecordÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: $recordId")
            return
        }

        if (record.transcript.isNullOrEmpty()) {
            Log.e("RecordViewModel", "‚ùå TranscriptÍ∞Ä ÎπÑÏñ¥ÏûàÏùå. Llama Î∂ÑÏÑù Î∂àÍ∞Ä")
            recordStorage.updateProcessStatus(recordId, analysisStatus = ProcessStatus.FAILED)
            return
        }

        Log.d("RecordViewModel", "üìù ÏûÖÎ†• Transcript:")
        Log.d("RecordViewModel", "  ${record.transcript}")

        try {
            // TODO: Ïã§Ï†ú Llama Ïò®-ÎîîÎ∞îÏù¥Ïä§ Ï≤òÎ¶¨ Î°úÏßÅ
            val analysisResult = """
            [
                {
                    "title": "Î≥ëÏõê ÏßÑÎ£å",
                    "description": "Ï†ïÍ∏∞ Í≤ÄÏßÑ ÏòàÏïΩ",
                    "startDate": "2025-05-28T14:00:00.000Z",
                    "endDate": "2025-05-28T15:00:00.000Z"
                },
                {
                    "title": "ÏïΩÍµ≠ Î∞©Î¨∏",
                    "description": "Ï≤òÎ∞©Ï†Ñ Ï°∞Ï†ú",
                    "startDate": "2025-05-28T15:30:00.000Z",
                    "endDate": "2025-05-28T16:00:00.000Z"
                }
            ]
            """.trimIndent()

            Log.d("RecordViewModel", "üß† Llama Î∂ÑÏÑù Í≤∞Í≥º:")
            Log.d("RecordViewModel", "  Í≤∞Í≥º Í∏∏Ïù¥: ${analysisResult.length}Ïûê")
            Log.d("RecordViewModel", "  Î∂ÑÏÑù ÎÇ¥Ïö©:")
            Log.d("RecordViewModel", analysisResult)

            recordStorage.updateAnalysisResult(recordId, analysisResult, ProcessStatus.COMPLETED)
            Log.d("RecordViewModel", "‚úÖ Llama Î∂ÑÏÑù ÏôÑÎ£å Î∞è Ï†ÄÏû• ÏÑ±Í≥µ")

        } catch (e: Exception) {
            Log.e("RecordViewModel", "‚ùå Llama Î∂ÑÏÑù Ïã§Ìå®: ${e.message}", e)
            recordStorage.updateProcessStatus(recordId, analysisStatus = ProcessStatus.FAILED)
        }
    }

    // ÏùºÏ†ï ÌååÏã± Ï≤òÎ¶¨ (CallDetailScreenÏùò ÌååÏã± Ìï®Ïàò ÌôúÏö©)
    private suspend fun parseScheduleFromResult(recordId: String) {
        Log.d("RecordViewModel", "üìÖ ÏùºÏ†ï ÌååÏã± ÏãúÏûë: $recordId")
        val record = recordStorage.getRecordById(recordId) ?: run {
            Log.e("RecordViewModel", "‚ùå RecordÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: $recordId")
            return
        }

        if (record.result.isNullOrEmpty()) {
            Log.e("RecordViewModel", "‚ùå Llama Í≤∞Í≥ºÍ∞Ä ÎπÑÏñ¥ÏûàÏùå. ÌååÏã± Î∂àÍ∞Ä")
            recordStorage.updateProcessStatus(recordId, parseStatus = ProcessStatus.FAILED)
            return
        }

        Log.d("RecordViewModel", "üß† ÌååÏã±Ìï† Llama Í≤∞Í≥º:")
        Log.d("RecordViewModel", record.result)

        try {
            // CallDetailScreenÏùò parseLlamaScheduleResponseFull Ìï®ÏàòÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÌååÏã±
            val extractedSchedules = parseLlamaScheduleResponseFull(
                record.result,
                recordId,
                record.userId
            )

            Log.d("RecordViewModel", "üìÖ ÌååÏã± Í≤∞Í≥º:")
            Log.d("RecordViewModel", "  Ï∂îÏ∂úÎêú ÏùºÏ†ï Ïàò: ${extractedSchedules.size}")

            extractedSchedules.forEachIndexed { index, schedule ->
                Log.d("RecordViewModel", "  üìÖ ÏùºÏ†ï ${index + 1}:")
                Log.d("RecordViewModel", "    - ID: ${schedule.localId}")
                Log.d("RecordViewModel", "    - Ï†úÎ™©: ${schedule.title}")
                Log.d("RecordViewModel", "    - ÏÑ§Î™Ö: ${schedule.description}")
                Log.d("RecordViewModel", "    - ÏãúÏûë: ${schedule.startDate}")
                Log.d("RecordViewModel", "    - Ï¢ÖÎ£å: ${schedule.endDate}")
                Log.d("RecordViewModel", "    - AI ÏÉùÏÑ±: ${schedule.isAi}")
                Log.d("RecordViewModel", "    - ÎèôÍ∏∞Ìôî ÏÉÅÌÉú: ${schedule.syncStatus}")
            }

            recordStorage.updateExtractedSchedules(recordId, extractedSchedules, ProcessStatus.COMPLETED)
            Log.d("RecordViewModel", "‚úÖ ÏùºÏ†ï ÌååÏã± ÏôÑÎ£å Î∞è Ï†ÄÏû• ÏÑ±Í≥µ")

            // Ï†ÄÏû• ÌõÑ Í≤ÄÏ¶ù
            val updatedRecord = recordStorage.getRecordById(recordId)
            Log.d("RecordViewModel", "üîç Ï†ÄÏû• Í≤ÄÏ¶ù:")
            Log.d("RecordViewModel", "  Ï†ÄÏû•Îêú ÏùºÏ†ï Ïàò: ${updatedRecord?.extractedSchedules?.size ?: 0}")
            Log.d("RecordViewModel", "  ÌååÏã± ÏÉÅÌÉú: ${updatedRecord?.parseStatus}")

        } catch (e: Exception) {
            Log.e("RecordViewModel", "‚ùå ÏùºÏ†ï ÌååÏã± Ïã§Ìå®: ${e.message}", e)
            recordStorage.updateProcessStatus(recordId, parseStatus = ProcessStatus.FAILED)
        }
    }

    // ÌäπÏ†ï RecordÏùò Ï∂îÏ∂úÎêú ÏùºÏ†ïÎì§ Ï°∞Ìöå
    fun getExtractedSchedulesForRecord(recordId: String): List<SimpleSchedule> {
        return _records.value
            .find { it.localId == recordId }
            ?.extractedSchedules ?: emptyList()
    }

    // Ï∂îÏ∂úÎêú ÏùºÏ†ïÎì§ÏùÑ Í∏∞Ï°¥ SimpleSchedule ÏãúÏä§ÌÖúÏóê Ï†ÄÏû•
    fun exportExtractedSchedulesToSimpleSchedule(recordId: String, scheduleIndices: List<Int>? = null) {
        viewModelScope.launch {
            Log.d("RecordViewModel", "=== ÏùºÏ†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏãúÏûë ===")
            Log.d("RecordViewModel", "Record ID: $recordId")

            val record = recordStorage.getRecordById(recordId) ?: run {
                Log.e("RecordViewModel", "‚ùå RecordÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: $recordId")
                return@launch
            }

            val extractedSchedules = record.extractedSchedules ?: run {
                Log.w("RecordViewModel", "‚ö†Ô∏è Ï∂îÏ∂úÎêú ÏùºÏ†ïÏù¥ ÏóÜÏùå")
                return@launch
            }

            Log.d("RecordViewModel", "üìÖ Ï¥ù Ï∂îÏ∂úÎêú ÏùºÏ†ï: ${extractedSchedules.size}Í∞ú")

            val schedulesToExport = if (scheduleIndices != null) {
                Log.d("RecordViewModel", "üìã ÏÑ†ÌÉùÎêú Ïù∏Îç±Ïä§: $scheduleIndices")
                scheduleIndices.mapNotNull { index ->
                    extractedSchedules.getOrNull(index)
                }
            } else {
                Log.d("RecordViewModel", "üìã Î™®Îì† ÏùºÏ†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞")
                extractedSchedules // Î™®Îì† ÏùºÏ†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞
            }

            Log.d("RecordViewModel", "üíæ ÎÇ¥Î≥¥ÎÇº ÏùºÏ†ï: ${schedulesToExport.size}Í∞ú")

            var successCount = 0
            var failCount = 0

            schedulesToExport.forEach { schedule ->
                try {
                    Log.d("RecordViewModel", "üì• ÏùºÏ†ï Ï†ÄÏû• ÏãúÎèÑ: ${schedule.title}")
                    val result = simpleLocalStorage.saveSchedule(schedule)

                    if (result.isSuccess) {
                        successCount++
                        Log.d("RecordViewModel", "‚úÖ ÏùºÏ†ï Ï†ÄÏû• ÏÑ±Í≥µ: ${schedule.title}")
                    } else {
                        failCount++
                        Log.e("RecordViewModel", "‚ùå ÏùºÏ†ï Ï†ÄÏû• Ïã§Ìå®: ${schedule.title}, Ïò§Î•ò: ${result.exceptionOrNull()?.message}")
                    }
                } catch (e: Exception) {
                    failCount++
                    Log.e("RecordViewModel", "‚ùå ÏùºÏ†ï Ï†ÄÏû• ÏòàÏô∏: ${schedule.title}", e)
                }
            }

            Log.d("RecordViewModel", "üìä ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Í≤∞Í≥º:")
            Log.d("RecordViewModel", "  ‚úÖ ÏÑ±Í≥µ: ${successCount}Í∞ú")
            Log.d("RecordViewModel", "  ‚ùå Ïã§Ìå®: ${failCount}Í∞ú")
            Log.d("RecordViewModel", "=== ÏùºÏ†ï ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å ===")
        }
    }

    // Î™®Îì† RecordÏóêÏÑú Ï∂îÏ∂úÎêú ÏùºÏ†ïÎì§ Ï°∞Ìöå
    fun getAllExtractedSchedules(): List<Pair<String, SimpleSchedule>> {
        return _records.value
            .mapNotNull { record ->
                record.extractedSchedules?.map { schedule ->
                    record.localId to schedule
                }
            }
            .flatten()
    }

    // Ï≤òÎ¶¨ ÎåÄÍ∏∞Ï§ëÏù∏ RecordÎì§ Ï°∞Ìöå
    fun getPendingRecords(): List<Record> {
        return _records.value.filter {
            it.transcriptStatus == ProcessStatus.PENDING ||
                    it.analysisStatus == ProcessStatus.PENDING ||
                    it.parseStatus == ProcessStatus.PENDING
        }
    }

    // üîß ÌÖåÏä§Ìä∏Ïö© Ìï®ÏàòÎì§

    // Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏÉÅÌÉú Î°úÍ∑∏ Ï∂úÎ†•
    fun logAllData() {
        Log.d("RecordViewModel", "=== Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏÉÅÌÉú Î°úÍ∑∏ ===")
        val records = _records.value
        Log.d("RecordViewModel", "üìä Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ:")
        Log.d("RecordViewModel", "  - Ï¥ù Record Ïàò: ${records.size}")
        Log.d("RecordViewModel", "  - Ï≤òÎ¶¨ ÎåÄÍ∏∞Ï§ë: ${getPendingRecords().size}")
        Log.d("RecordViewModel", "  - Ï≤òÎ¶¨ Ï§ë: ${records.count { it.transcriptStatus == ProcessStatus.PROCESSING || it.analysisStatus == ProcessStatus.PROCESSING || it.parseStatus == ProcessStatus.PROCESSING }}")
        Log.d("RecordViewModel", "  - ÏôÑÎ£å: ${records.count { it.transcriptStatus == ProcessStatus.COMPLETED && it.analysisStatus == ProcessStatus.COMPLETED && it.parseStatus == ProcessStatus.COMPLETED }}")
        Log.d("RecordViewModel", "  - Ïã§Ìå®: ${records.count { it.transcriptStatus == ProcessStatus.FAILED || it.analysisStatus == ProcessStatus.FAILED || it.parseStatus == ProcessStatus.FAILED }}")

        val totalSchedules = records.sumOf { it.extractedSchedules?.size ?: 0 }
        Log.d("RecordViewModel", "  - Ï¥ù Ï∂îÏ∂úÎêú ÏùºÏ†ï: ${totalSchedules}Í∞ú")
        Log.d("RecordViewModel", "================================")
    }

    // ÌäπÏ†ï Record ÏÉÅÏÑ∏ Î°úÍ∑∏
    fun logRecordDetails(recordId: String) {
        Log.d("RecordViewModel", "=== Record ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ===")
        val record = _records.value.find { it.localId == recordId }
        if (record != null) {
            Log.d("RecordViewModel", "üìã Record: ${record.name}")
            Log.d("RecordViewModel", "  - ID: ${record.localId}")
            Log.d("RecordViewModel", "  - ÏÇ¨Ïö©Ïûê: ${record.userId}")
            Log.d("RecordViewModel", "  - ÌååÏùº: ${record.path}")
            Log.d("RecordViewModel", "  - ÌÅ¨Í∏∞: ${record.size} bytes")
            Log.d("RecordViewModel", "  - ÏÉÅÌÉú: T:${record.transcriptStatus}, A:${record.analysisStatus}, P:${record.parseStatus}")
            Log.d("RecordViewModel", "  - Transcript: ${record.transcript?.length ?: 0}Ïûê")
            Log.d("RecordViewModel", "  - Analysis: ${record.result?.length ?: 0}Ïûê")
            Log.d("RecordViewModel", "  - ÏùºÏ†ï Ïàò: ${record.extractedSchedules?.size ?: 0}")

            record.extractedSchedules?.forEachIndexed { index, schedule ->
                Log.d("RecordViewModel", "    üìÖ ÏùºÏ†ï ${index + 1}: ${schedule.title} (${schedule.startDate})")
            }
        } else {
            Log.w("RecordViewModel", "‚ö†Ô∏è RecordÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: $recordId")
        }
        Log.d("RecordViewModel", "========================")
    }

    // JSON ÏßÅÎ†¨Ìôî ÌÖåÏä§Ìä∏
    fun testJsonSerialization() {
        viewModelScope.launch {
            Log.d("RecordViewModel", "=== JSON ÏßÅÎ†¨Ìôî ÌÖåÏä§Ìä∏ ===")
            val records = recordStorage.getAllRecords()

            records.forEach { record ->
                Log.d("RecordViewModel", "üß™ Record: ${record.name}")
                Log.d("RecordViewModel", "  - ÏùºÏ†ï Ïàò: ${record.extractedSchedules?.size ?: 0}")

                // JSONÏúºÎ°ú Î≥ÄÌôò ÌõÑ Îã§Ïãú ÌååÏã± ÌÖåÏä§Ìä∏
                try {
                    val gson = com.google.gson.Gson()
                    val json = gson.toJson(record)
                    val parsedRecord = gson.fromJson(json, Record::class.java)

                    Log.d("RecordViewModel", "  ‚úÖ JSON ÏßÅÎ†¨Ìôî/Ïó≠ÏßÅÎ†¨Ìôî ÏÑ±Í≥µ")
                    Log.d("RecordViewModel", "  - ÏõêÎ≥∏ ÏùºÏ†ï Ïàò: ${record.extractedSchedules?.size ?: 0}")
                    Log.d("RecordViewModel", "  - Î≥µÏõê ÏùºÏ†ï Ïàò: ${parsedRecord.extractedSchedules?.size ?: 0}")

                } catch (e: Exception) {
                    Log.e("RecordViewModel", "  ‚ùå JSON Ï≤òÎ¶¨ Ïã§Ìå®: ${e.message}")
                }
            }
            Log.d("RecordViewModel", "========================")
        }
    }
}